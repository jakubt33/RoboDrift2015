/*
 * init.c
 *
 *  Created on: 7 mar 2015
 *      Author: Kuba
 */

#include <avr/io.h>
#include "io.h"
#include "main.h"
#include "RFM69registers.h"
#include "RFM69.h"

void init_SPI_slave(){/*
	DDR_SPI |= (1<<MISO);
	DDR_SPI &= ~(1 << SS);
	DDR_SPI &= ~(1 << SCK);
	DDR_SPI &= ~(1 << MOSI);
	SPCR = (1 << SPIE)|(1 << SPE); //spi interrupt enable*/
}

void init_RFM69(){

	MyAddress = 51; //no trivial number

	select();
	do writeReg(REG_SYNCVALUE1, 0xAA); while (readReg(REG_SYNCVALUE1) != 0xAA);
	do writeReg(REG_SYNCVALUE1, 0x55); while (readReg(REG_SYNCVALUE1) != 0x55);

	writeReg(REG_OPMODE, RF_OPMODE_STANDBY); //default, standby
	writeReg(REG_DATAMODUL, RF_DATAMODUL_DATAMODE_PACKET | RF_DATAMODUL_MODULATIONTYPE_FSK | RF_DATAMODUL_MODULATIONSHAPING_00);//no shaping
	writeReg(REG_BITRATEMSB, RF_BITRATEMSB_4800); //by default: 4.8 KBPS
    writeReg(REG_BITRATELSB, RF_BITRATELSB_4800);
    writeReg(REG_FDEVMSB, RF_FDEVMSB_50000); // default: 5KHz, (FDEV + BitRate / 2 <= 500KHz)
    writeReg(REG_FDEVLSB, RF_FDEVLSB_50000); //frequency diviation

    writeReg(REG_FRFMSB, (uint8_t) (RF_FRFMSB_434));
	writeReg(REG_FRFMID, (uint8_t) (RF_FRFMID_434));
	writeReg(REG_FRFLSB, (uint8_t) (RF_FRFLSB_434));

	writeReg(REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_5); //not sure about this

	writeReg(REG_SYNCCONFIG, RF_SYNC_ON | RF_SYNC_FIFOFILL_AUTO | RF_SYNC_SIZE_2 | RF_SYNC_TOL_0); //sync word size 2bytes
	writeReg(REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_10); //dio0 high when fifo not empty
	writeReg(REG_SYNCVALUE1, 0x2D); //first byte of sync word
	writeReg(REG_SYNCVALUE2, 99); //newtowrkID, uint8_t
	writeReg(REG_PACKETCONFIG1, RF_PACKET1_FORMAT_FIXED|RF_PACKET1_DCFREE_OFF | RF_PACKET1_CRC_ON | RF_PACKET1_CRCAUTOCLEAR_ON | RF_PACKET1_ADRSFILTERING_OFF); //pocket mode
	//writeReg(REG_NODEADRS, nodeID);
	writeReg(REG_PAYLOADLENGTH, 2); //payloadlengh = 1; only 1 data(or address) byte
	writeReg(REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_2BITS | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF);//not sure about it

	writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages
	unselect();
}

void init_SPI_master(){
	DDR_SPI |= (1 << SCK)|(1 << SS)|(1 << MOSI); // wyjcie na tych pinach
	SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ); //spi enable, atmega = master, Prescaler 16
	//SPCR |= (1 << SPIE); //spi interrupt enable
}

void init_IO() {
	DDR_LED |= (1 << LED1);
	DDR_LED |= (1 << LED2);
	DDR_LED |= (1 << LED3);
	DDR_LED |= (1 << LED4);
	DDR_LED |= (1 << LED5);

	DDR_LED_BATT |= (1 << LED_BATT_GR);
	DDR_LED_BATT |= (1 << LED_BATT_RED);

	DDR_STRIPE |= (1 << LED_STRIPE);
	DDR_TSAL |= (1 <<  TSAL_ENABLE);

	DDR_SWITCH &= ~(1 << SWITCH_DOWN);
	DDR_SWITCH &= ~(1 << SWITCH_OK);
	DDR_SWITCH &= ~(1 << SWITCH_UP);

	DDR_TSOP &= ~(_BV(TSOP));


	SensorID=0;
	RaceStart=0;

	TsalCounter=0;
	TsalGapCounter=0;

	ovf=0;
	ADC_level=0;
}

void init_TSAL(){
	TCCR1B |= (1<<WGM12)|(1<<CS10); //CTC max OCR1A, prescaler1
	TCCR1A |= (1<<COM1A0); //toggle PB1 on compare match
	OCR1A = 12; //to get f~38khz 12
	TCNT1 = 0;

    TIMSK |= (1<<OCIE1A); //Interrupt enable on comapre match
    //TIFR |= (1<<OCF1A);
}

void init_batteries() {
	ADMUX |= (1<<MUX2)|(1<<MUX1); //ADC6
	ADCSRA |= (1<<ADPS1) | (1<<ADPS0); //prescaler 8  100000/8=125khz adc
	ADMUX |= (1<<ADLAR); //left adjutment
	ADMUX |= (1<<REFS0); //avcc with external capacitor at AREF pin

	//init_batt timer
    TCCR2 |= (1<<CS22)|(1<<CS21)|(1<<CS20); //prescaler 1024 - 1kHz, 1 OVF=0,25s
    TCNT2 = 0;
    TIMSK |= (1<<TOIE2); //overflow
}

uint8_t check_ADC(){
	ADCSRA |= (1<<ADEN); //ADEN: ADC Enable (uruchomienie przetwornika)
	ADCSRA |= (1<<ADSC);

	while(ADCSRA & (1<<ADSC));

	ADCSRA &= ~(1<<ADEN); //ADEN: ADC Enable (uruchomienie przetwornika)
	return ADCH;
}
void init_TSOP(){
	DDRD &= ~(1<<PD2);
	MCUCR |= (0<<ISC01)|(1<<ISC00); //any logical change generates interrupt request
	GICR |= (1<<INT0);
}
